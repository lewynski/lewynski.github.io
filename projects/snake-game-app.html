<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cyber Viper</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body { 
        background-color: #050505; 
        font-family: 'Press Start 2P', cursive; 
        touch-action: none; 
        overflow: hidden;
    }
    
    /* Cyber Grid Background */
    #game-wrapper {
        position: relative;
        box-shadow: 0 0 40px rgba(34, 197, 94, 0.2);
        border: 2px solid #333;
        background-image: 
            linear-gradient(rgba(0, 255, 0, 0.03) 1px, transparent 1px),
            linear-gradient(90deg, rgba(0, 255, 0, 0.03) 1px, transparent 1px);
        background-size: 20px 20px;
        background-color: #0a0a0a;
    }

    canvas { display: block; }

    /* Button Styles */
    .d-btn {
        background: #111;
        border: 1px solid #333;
        color: #4ade80;
        border-radius: 8px;
        font-size: 1.2rem;
        transition: all 0.1s;
        box-shadow: 0 4px 0 #222;
    }
    .d-btn:active { 
        background: #222; 
        transform: translateY(4px); 
        box-shadow: 0 0 0 #222; 
    }
    
    .boost-btn {
        border-color: #f59e0b;
        color: #f59e0b;
        box-shadow: 0 4px 0 #78350f;
    }

    .glow-text { text-shadow: 0 0 10px rgba(34, 197, 94, 0.8); }

    /* Shake Animation for Game Over */
    @keyframes glitch {
        0% { transform: translate(0); }
        20% { transform: translate(-2px, 2px); filter: hue-rotate(90deg); }
        40% { transform: translate(-2px, -2px); }
        60% { transform: translate(2px, 2px); }
        80% { transform: translate(2px, -2px); filter: hue-rotate(-90deg); }
        100% { transform: translate(0); }
    }
    .glitching { animation: glitch 0.3s cubic-bezier(.25, .46, .45, .94) both infinite; }
  </style>
</head>
<body class="flex flex-col items-center justify-center h-screen text-white p-2">

  <div class="flex justify-between w-full max-w-[400px] mb-2 px-2 text-xs">
      <div class="text-green-400">SCORE: <span id="score">0</span></div>
      <div class="text-yellow-500">SPD: <span id="speed-lvl">1x</span></div>
      <div class="text-gray-500">HI: <span id="high-score">0</span></div>
  </div>

  <div id="game-wrapper" class="rounded-lg">
      <canvas id="gameCanvas" width="400" height="400"></canvas>
      
      <div id="start-screen" class="absolute inset-0 flex flex-col items-center justify-center bg-black/85 z-10 backdrop-blur-sm">
          <h1 class="text-3xl text-green-500 glow-text mb-4 text-center leading-relaxed">CYBER<br>VIPER</h1>
          <p class="text-[0.6rem] text-gray-400 mb-6 text-center leading-relaxed">
              ARROWS to Move<br>SPACE to Boost<br><span class="text-yellow-500">Speed increases every 5 pts</span>
          </p>
          <button onclick="startGame()" class="px-6 py-3 bg-green-600 hover:bg-green-500 text-black font-bold text-xs rounded shadow-[0_0_15px_rgba(34,197,94,0.6)] transition-all">
              INITIALIZE
          </button>
      </div>

      <div id="game-over-screen" class="hidden absolute inset-0 flex flex-col items-center justify-center bg-black/90 z-20">
          <h2 class="text-red-500 text-2xl mb-2 glitch-text">CRITICAL FAILURE</h2>
          <p class="text-xs text-gray-300 mb-6">Final Score: <span id="final-score" class="text-white">0</span></p>
          <button onclick="startGame()" class="px-6 py-3 border-2 border-green-500 text-green-500 hover:bg-green-500/20 text-xs rounded font-bold transition-all">
              REBOOT SYSTEM
          </button>
      </div>
  </div>

  <div class="flex gap-4 mt-4 w-full max-w-[400px] justify-center items-end">
      <div class="grid grid-cols-3 gap-1 w-[140px]">
          <div></div>
          <button class="d-btn h-10" onclick="handleInput('up')">▲</button>
          <div></div>
          <button class="d-btn h-10" onclick="handleInput('left')">◀</button>
          <button class="d-btn h-10" onclick="handleInput('down')">▼</button>
          <button class="d-btn h-10" onclick="handleInput('right')">▶</button>
      </div>

      <button class="d-btn boost-btn h-14 w-20 text-[0.6rem] font-bold" 
              ontouchstart="boost(true)" ontouchend="boost(false)" 
              onmousedown="boost(true)" onmouseup="boost(false)">
          BOOST
      </button>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const wrapper = document.getElementById('game-wrapper');
    
    // Config
    const GRID_SIZE = 20;
    const TILE_COUNT = canvas.width / GRID_SIZE;
    
    // State
    let snake = [];
    let food = { x: 15, y: 15 };
    let particles = [];
    let dx = 0;
    let dy = 0;
    
    let score = 0;
    let highScore = localStorage.getItem('snakeHi') || 0;
    
    let baseSpeed = 100; // ms per frame
    let currentSpeed = 100;
    let isBoosting = false;
    let gameTimeout;
    let isRunning = false;

    document.getElementById('high-score').innerText = highScore;

    function startGame() {
        // Reset
        snake = [{x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10}];
        score = 0;
        baseSpeed = 120; // Starting speed (slower)
        currentSpeed = baseSpeed;
        particles = [];
        dx = 1; dy = 0; // Move right initially
        
        isRunning = true;
        wrapper.classList.remove('glitching');
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        updateHUD();
        
        clearTimeout(gameTimeout);
        gameLoop();
    }

    function gameLoop() {
        if(!isRunning) return;

        update();
        draw();

        // Dynamic Speed: Boost cuts delay in half
        let delay = isBoosting ? currentSpeed / 2 : currentSpeed;
        gameTimeout = setTimeout(gameLoop, delay);
    }

    function update() {
        // Update Particles
        for(let i=particles.length-1; i>=0; i--) {
            particles[i].life--;
            particles[i].x += particles[i].vx;
            particles[i].y += particles[i].vy;
            if(particles[i].life <= 0) particles.splice(i, 1);
        }

        // Move Head
        const head = { x: snake[0].x + dx, y: snake[0].y + dy };

        // Wall Collision
        if (head.x < 0 || head.x >= TILE_COUNT || head.y < 0 || head.y >= TILE_COUNT) {
            gameOver();
            return;
        }

        // Self Collision
        for (let part of snake) {
            if (part.x === head.x && part.y === head.y) {
                gameOver();
                return;
            }
        }

        snake.unshift(head);

        // Eat Food
        if (head.x === food.x && head.y === food.y) {
            score += 10;
            spawnParticles(head.x * GRID_SIZE + 10, head.y * GRID_SIZE + 10, '#facc15');
            placeFood();
            
            // Speed Up every 50 points (5 apples)
            if(score % 50 === 0 && baseSpeed > 40) {
                baseSpeed -= 5;
                currentSpeed = baseSpeed;
            }
            updateHUD();
        } else {
            snake.pop();
        }
    }

    function draw() {
        // Clear
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw Food (Pulsing)
        ctx.fillStyle = '#facc15';
        ctx.shadowBlur = 15; ctx.shadowColor = "#facc15";
        ctx.beginPath();
        ctx.arc(food.x * GRID_SIZE + 10, food.y * GRID_SIZE + 10, 8, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Draw Snake
        snake.forEach((part, index) => {
            let x = part.x * GRID_SIZE;
            let y = part.y * GRID_SIZE;
            
            if(index === 0) {
                // Head
                ctx.fillStyle = isBoosting ? '#bef264' : '#4ade80'; // Lighter if boosting
                ctx.shadowBlur = 15; 
                ctx.shadowColor = isBoosting ? '#bef264' : '#22c55e';
                ctx.fillRect(x, y, GRID_SIZE, GRID_SIZE);
                
                // Eyes
                ctx.fillStyle = '#000';
                ctx.fillRect(x + 4, y + 4, 4, 4);
                ctx.fillRect(x + 12, y + 4, 4, 4);
                ctx.shadowBlur = 0;
            } else {
                // Body
                ctx.fillStyle = '#15803d'; // Darker Green
                ctx.fillRect(x+1, y+1, GRID_SIZE-2, GRID_SIZE-2);
            }
        });

        // Draw Particles
        particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life / 20;
            ctx.fillRect(p.x, p.y, p.size, p.size);
            ctx.globalAlpha = 1.0;
        });
    }

    function spawnParticles(x, y, color) {
        for(let i=0; i<8; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                life: 20 + Math.random() * 10,
                color: color,
                size: 3 + Math.random() * 4
            });
        }
    }

    function placeFood() {
        food = {
            x: Math.floor(Math.random() * TILE_COUNT),
            y: Math.floor(Math.random() * TILE_COUNT)
        };
        // Don't spawn on snake
        for(let part of snake) {
            if(part.x === food.x && part.y === food.y) placeFood();
        }
    }

    function gameOver() {
        isRunning = false;
        clearTimeout(gameTimeout);
        wrapper.classList.add('glitching'); // Visual Effect

        if(score > highScore) {
            highScore = score;
            localStorage.setItem('snakeHi', highScore);
        }

        document.getElementById('final-score').innerText = score;
        document.getElementById('game-over-screen').classList.remove('hidden');
    }

    function updateHUD() {
        document.getElementById('score').innerText = score;
        document.getElementById('high-score').innerText = highScore;
        // Calculate speed level roughly
        let lvl = Math.floor((120 - baseSpeed) / 5) + 1;
        document.getElementById('speed-lvl').innerText = lvl + "x";
    }

    // Input
    function handleInput(dir) {
        if(dir === 'up' && dy === 0) { dx = 0; dy = -1; }
        if(dir === 'down' && dy === 0) { dx = 0; dy = 1; }
        if(dir === 'left' && dx === 0) { dx = -1; dy = 0; }
        if(dir === 'right' && dx === 0) { dx = 1; dy = 0; }
    }

    function boost(active) {
        isBoosting = active;
    }

    // Keyboard
    document.addEventListener('keydown', e => {
        if(e.code === 'ArrowUp') handleInput('up');
        if(e.code === 'ArrowDown') handleInput('down');
        if(e.code === 'ArrowLeft') handleInput('left');
        if(e.code === 'ArrowRight') handleInput('right');
        if(e.code === 'Space') boost(true);
    });
    
    document.addEventListener('keyup', e => {
        if(e.code === 'Space') boost(false);
    });

  </script>
</body>
</html>
